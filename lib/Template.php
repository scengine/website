<?php
/* LICENSE
 * 
 * BanSE - a site base (designed to be the SCEngine website)
 * Copyright (C) 2007-2012 Colomban Wendling <ban@herbesfolles.org>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 */

/* Simple template engine
 * 
 * Supports variable replacement, foreach loop and if conditions.
 */

require_once ('lib/string.php');


/* FIXME: don't let this be externally visible */
static $V = '[_a-zA-Z][_a-zA-Z0-9]*';
static $D = '[ \t\r\n\v]';
static $N = '[+-]?[0-9]+';
$COND = "(?:(${N})|(${V})(?:${D}*\[${D}*(${V}|${N}|'[^']+'|\"[^\"]+\")${D}*\])*)";
define ('TPL_FOREACH_PATTERN', "/^foreach${D}+(?:(${V})${D}*,${D}*)?(${V})${D}+in${D}+(${COND})$/");
define ('TPL_IF_PATTERN', "/^if${D}+(${COND})$/");
define ('TPL_VAR_PATTERN', "/^${COND}$/");




abstract class Template
{
	protected $tpl = '';
	protected $vars = array ();
	
	public function __set ($name, $value)
	{
		$this->vars[$name] = $value;
	}
	
	public function __get ($name)
	{
		if (array_key_exists ($name, $this->vars)) {
			return $this->vars[$name];
		}
		
		$trace = debug_backtrace ();
		trigger_error ('Undefined property "'.$name.'" '.
		               '(from file "'.$trace[0]['file'].'" '.
		               'at line '.$trace[0]['line'].')',
		               E_USER_NOTICE);
		return null;
	}
	
	/* old, replace-only, but fast engine (no conditions, no loops)
	public function __toString ()
	{
		$replaces = array ();
		$searches = array ();
		
		foreach ($this->vars as $search => &$replace) {
			$searches[] = '{'.$search.'}';
			if (is_array ($replace)) {
				$actual_replace = '';
				foreach ($replace as &$item) {
					$actual_replace .= (string) $item;
				}
				$replaces[] = &$actual_replace;
			} else {
				$replaces[] = (string) $replace;
			}
		}
		
		return str_replace ($searches, $replaces, $this->tpl);
	}
	*/
	
	/* creates an array of the tokens in the template, e.g.
	 * array('foo ', '{bar}') for input 'foo {bar}' */
	private function tokenize ()
	{
		$tokens = array ();
		$ppos = 0;
		$pos = 0;
		
		while (($pos = strpos ($this->tpl, '{', $pos)) !== false) {
			$tokens[] = substr ($this->tpl, $ppos, $pos - $ppos);
			
			if (($epos = strpos ($this->tpl, '}', $pos + 1)) === false) {
				return false;
			} else {
				$epos;
				$token = substr ($this->tpl, $pos + 1, $epos - ($pos + 1));
				$tokens[] = '{' . trim ($token) . '}';
				$pos = $epos + 1;
			}
			$ppos = $pos;
		}
		
		$tokens[] = substr ($this->tpl, $ppos);
		
		return $tokens;
	}
	
	/* unfolds the tokens generated by tokenize() to create a tree */
	private static function unfold_tokens (array $tokens)
	{
		$expanded_tokens = array ();
		$levels = array (&$expanded_tokens);
		
		foreach ($tokens as &$token) {
			$cmd = substr ($token, 1, -1);
			
			if (preg_match (TPL_FOREACH_PATTERN, $cmd, $matches)) {
				array_unshift ($levels, array ());
				$levels[1][] = array (
					'foreach',
					$matches[1], /* key */
					$matches[2], /* value */
					$matches[3], /* expression */
					&$levels[0]  /* body */
				);
			} else if (preg_match (TPL_IF_PATTERN, $cmd, $matches)) {
				array_unshift ($levels, array ());
				$levels[1][] = array (
					'if',
					$matches[1],  /* condition */
					&$levels[0],  /* if branch */
					array ()      /* else branch */
				);
			} else if ($token == '{else}') {
				if (count ($levels) < 2 ||
						($k = count ($levels[1]) - 1) < 0 ||
						! is_array ($levels[1][$k]) ||
						$levels[1][$k][0] != 'if') {
					die ('ERROR: else without an if before');
					return null;
				}
				array_shift ($levels);
				array_unshift ($levels, array ());
				$levels[1][$k][3] = &$levels[0];
			} else if ($token == '{end}') {
				array_shift ($levels);
				if (count ($levels) < 1) {
					die ('ERROR: end with no open block');
					return null;
				}
			} else {
				$levels[0][] = $token;
			}
		}
		
		return $expanded_tokens;
	}
	
	/* if $var is an array, flattens it using $sep as the separator
	 * otherwise, return $var casted to string */
	private static function str_var ($var, $sep = '')
	{
		if (is_array ($var)) {
			$tmp = null;
			foreach ($var as &$v) {
				if ($tmp === null) {
					$tmp = '';
				} else {
					$tmp .= $sep;
				}
				$tmp .= self::str_var ($v, $sep);
			}
			$var = $tmp;
		}
		
		return (string) $var;
	}
	
	private static function parse_var ($expr, array &$vars, $flat = true)
	{
		if (! preg_match (TPL_VAR_PATTERN, $expr, $matches)) {
			die ('ERROR: invalid expression: '.$expr);
		} else {
			if (! empty ($matches[2])) {
				$var = $matches[2]; /* var name */
			} else {
				$var = $matches[1]; /* numeric */
			}
			$indices = array_slice ($matches, 3); /* array indices */
			
			foreach ($indices as &$idx) {
				if ($idx[0] == '"' || $idx[0] == '\'') {
					$idx = substr ($idx, 1, -1);
				} else {
					$idx = self::parse_var ($idx, $vars);
				}
			}
			
			if (array_key_exists ($var, $vars)) {
				$var = $vars[$var];
				
				foreach ($indices as $idx) {
					if (! is_array ($var)) {
						die ('ERROR: variable "'.$var.'" is not an array');
					} else if (! array_key_exists ($idx, $var)) {
						die ('ERROR: array ['.self::str_var ($var, ',').'] has no key "'.$idx.'"');
					} else {
						$var = $var[$idx];
					}
				}
				if ($flat) {
					$var = self::str_var ($var);
				}
			}
			
			return $var;
		}
	}
	
	private static function parse_expr ($expr, array &$vars)
	{
		$tokens = explode (' ', $expr);
		$eval = '';
		
		foreach ($tokens as &$token) {
			$token = self::parse_var ($token, $vars);
		}
		
		return implode (' ', $tokens);
	}
	
	private static function parse (array $tokens, array &$vars)
	{
		$str = '';
		
		foreach ($tokens as $token) {
			if (is_array ($token)) {
				/* a condition or loop */
				
				switch ($token[0]) {
					case 'foreach':
						$array = self::parse_var ($token[3], $vars, false);
						
						if (! is_array ($array)) {
							die ('ERROR: variable "'.$token[3].'" is not an array');
						}
						foreach ($array as $k => $v) {
							$sub_vars = $vars;
							if (! empty ($token[1])) {
								$sub_vars[$token[1]] = $k;
							}
							$sub_vars[$token[2]] = $v;
							$str .= self::parse ($token[4], $sub_vars);
						}
						break;
					
					case 'if':
						$cond = self::parse_var ($token[1], $vars);
						
						if ($cond) {
							$str .= self::parse ($token[2], $vars);
						} else {
							$str .= self::parse ($token[3], $vars);
						}
						break;
					
					default:
						assert (0);
				}
			} else {
				$token_len = strlen ($token);
				
				if ($token_len > 0 && $token[0] == '{') {
					$expr = substr ($token, 1, $token_len - 2);
					$str .= self::parse_expr ($expr, $vars);
				} else {
					$str .= $token;
				}
			}
		}
		
		return $str;
	}
	
	public function __toString ()
	{
		$tokens = $this->tokenize ();
		$tokens = self::unfold_tokens ($tokens);
		
		return self::parse ($tokens, $this->vars);
	}
}

class FileTemplate extends Template
{
	public function __construct ($filename, array $vars = array ())
	{
		$this->tpl = file_get_contents ($filename);
		$this->vars = $vars;
	}
}

class StringTemplate extends Template
{
	public function __construct ($template, array $vars = array ())
	{
		$this->tpl = $template;
		$this->vars = $vars;
	}
}


/*

// simple example

$tpl = new StringTemplate ('Hello, {name}!');
$tpl->name = 'John';

echo $tpl;

// recursive example

$items = array ();
for ($i = 0; $i < 42; $i++) {
	$item = new StringTemplate ('<ul>{item}</ul>');
	$item->item = $i;
	$items[] = $item;
}
$tpl = new StringTemplate ('{items}');
$tpl->items = $items;

echo $tpl;

// creation-time variable definitions

$tpl = new StringTemplate (
	'{a} {b} {c}',
	array (
		'a' => 'first value',
		'b' => 'second value',
		'c' => new StringTemplate (
			'{x} {y}',
			array (
				'x' => 42,
				'y' => 84
			)
		)
	)
);

echo $tpl;

// loop example

$tpl = new StringTemplate (
	'{if title}<h3>{title}</h3>{end} {a}
	<ul>
		{foreach k,v in items}
			<li><a href="{k}">{v}</a></li>
		{end}
	</ul>',
	array (
		'title' => 'My list',
		'a' => array (array('lala')),
		'items' => array (
			'foo' => 'Foo',
			'bar' => 'Bar'
		)
	)
);

echo $tpl;

// conditions example

$tpl = new StringTemplate (
	'{if foo}
		foo is true
	{else}
		foo is false
	{end}',
	array (
		'foo' => 'lala'
	)
);

echo $tpl;


if (false && isset ($_SERVER['argv'])) {
	echo "\n\n=== from command line ===\n";
	
	$tpl = new StringTemplate ($_SERVER['argv'][1]);
	foreach ($_SERVER['argv'] as $a) {
		$el = explode ('=', $a);
		if (count ($el) > 1) {
			$sub = explode (',', $el[1]);
			if (count ($sub) < 2) {
				$sub = $el[1];
			}
			$tpl->__set ($el[0], $sub);
		}
	}
	
	echo $tpl;
}

//*/

